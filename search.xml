<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Kill for life</title>
    <url>/2022/08/31/Kill-for-life/</url>
    <content><![CDATA[<p>演示链接：<a href="https://www.bilibili.com/video/BV1WV4y1u7Nf/?vd_source=5e7331f28afe4ab47831db6b1fe009e8">https://www.bilibili.com/video/BV1WV4y1u7Nf/?vd_source=5e7331f28afe4ab47831db6b1fe009e8</a><br>项目链接：<a href="https://pan.baidu.com/s/1mzgb7vcdpKuqVgwNLqJsiw">https://pan.baidu.com/s/1mzgb7vcdpKuqVgwNLqJsiw</a><br>提取码：cqfq </p>
]]></content>
      <categories>
        <category>demo</category>
      </categories>
      <tags>
        <tag>Unreal Engine</tag>
      </tags>
  </entry>
  <entry>
    <title>C++常用算法</title>
    <url>/2022/09/04/C-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>通用</p>
<p>快读</p>
<p>快写</p>
<p>1、数学</p>
<p>快速幂</p>
<p>矩阵快速幂</p>
<p>排序算法（结构体，vector）</p>
<p>哈希</p>
<p>组合数</p>
<p>2、图论</p>
<p>并查集</p>
<p>线性筛</p>
<p>随机，卡时间</p>
<p>最短路径</p>
<p>st（）</p>
<p>线段树</p>
<p>树状数组</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>秋招复习</tag>
      </tags>
  </entry>
  <entry>
    <title>C++常用函数</title>
    <url>/2022/09/03/C-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="lower-bound-arr-arr-arr-size-val"><a href="#lower-bound-arr-arr-arr-size-val" class="headerlink" title="lower_bound(arr, arr + arr.size(), val)"></a><strong>lower_bound(arr, arr + arr.size(), val)</strong></h3><p>返回一个迭代器，返回指向大于等于val的第一个值的位置</p>
<p>lower_bound(arr,  arr + arr.size(), val) - arr </p>
<p>可以得到大于等于val数值的数组下标</p>
<p><em>&#x2F;&#x2F;升序队列，小顶堆</em> priority_queue &lt;int,vector<int>,greater<int> &gt; q; </int></int></p>
<p><em>&#x2F;&#x2F;降序队列，大顶堆</em> priority_queue &lt;int,vector<int>,less<int> &gt;q;</int></int></p>
<p>std::to_string(num) 将数字转换成string</p>
<p>fuck you</p>
<p>数组初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sum[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 只能初始化为0</span></span><br><span class="line"><span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="built_in">sizeof</span>(sum));</span><br><span class="line"><span class="comment">// 按字节赋值，通常用来赋值0或-1</span></span><br><span class="line"><span class="built_in">fill</span>(sum, sum + sum.<span class="built_in">size</span>(), <span class="number">0</span>); </span><br><span class="line"><span class="comment">// fill按单元赋值，将一个区间元素赋相同的值</span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(<span class="number">17</span>)</span></span>; </span><br><span class="line"><span class="comment">//初始化设置nums有17个元素，此时nums.push(123)从17个元素后面加</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(<span class="number">17</span>, <span class="number">3</span>)</span></span>; </span><br><span class="line"><span class="comment">//初始化设置nums有17个值为3的元素</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(sum)</span></span>;</span><br><span class="line"><span class="comment">// 将数组sum的元素复制到nums中</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">n2</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line"><span class="comment">// 将动态数组nums的元素复制到n2中</span></span><br><span class="line"><span class="built_in">fill</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 将动态数组nums中元素值全设为3</span></span><br><span class="line">nums.<span class="built_in">insert</span>(nums.<span class="built_in">begin</span>() + i, k)</span><br><span class="line"><span class="comment">// 在动态数组nums的第i个元素前插入k</span></span><br><span class="line">nums.<span class="built_in">insert</span>(nums.<span class="built_in">begin</span>() + i, k, val)</span><br><span class="line"><span class="comment">// 在动态数组nums的第i个元素前插入k个值为val的元素</span></span><br><span class="line">nums.<span class="built_in">insert</span>(nums.<span class="built_in">end</span>(), val)</span><br><span class="line"><span class="comment">// 在动态数组nums末尾插入val</span></span><br><span class="line"><span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>())</span><br><span class="line"><span class="comment">// 反转动态数组</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>秋招复习</tag>
      </tags>
  </entry>
  <entry>
    <title>常见排序算法对比</title>
    <url>/2022/09/01/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<h3 id="排序的种类"><a href="#排序的种类" class="headerlink" title="排序的种类"></a><strong>排序的种类</strong></h3><p>排序分为<strong>内部排序</strong>和<strong>外部排序</strong></p>
<p>一般为内部排序，可以划分为八大排序</p>
<p>八大排序算法是：1、直接插入排序；2、希尔排序；3、简单选择排序；4、堆排序；5、冒泡排序；6、快速排序；7、归并排序；8、桶排序&#x2F;基数排序。</p>
<p><img src="/2022/09/01/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/2021070910220936.png"></p>
<p><img src="/2022/09/01/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/123124.png"></p>
<h3 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a><strong>排序算法的稳定性</strong></h3><p>假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i] &#x3D; r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的。</p>
<p>冒泡排序中，只有左边的数字大于右边的数字时才会发生交换，相等的数字之间不会发生交换，所以它是稳定的。</p>
<p>而选择排序中，最小值和首位交换的过程可能会破坏稳定性。比如数列：[2, 2, 1]，在选择排序中第一次进行交换时，原数列中的两个 2 的相对顺序就被改变了，因此，我们说选择排序是不稳定的。</p>
<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a><strong>直接插入排序</strong></h3><p>思想：将一个数组中的数据看作两个数组，有序和无序数组，由于第一个无需比较，所以需要比n-1次，将无需数组的第一个与有序数组的最后一个依次对比，并且插入合适的位置</p>
<p><img src="/2022/09/01/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/v2-f87ad7d8ad54379dd81f02fcf9b91f49_b.gif"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span> arr[])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="type">int</span> next = arr[i + <span class="number">1</span>];</span><br><span class="line">		<span class="type">int</span> index = i;</span><br><span class="line">		<span class="keyword">while</span>(index &gt;= <span class="number">0</span> &amp;&amp; next &lt; arr[index]) &#123;</span><br><span class="line">			arr[index + <span class="number">1</span>] = arr[index];</span><br><span class="line">			index --;</span><br><span class="line">		&#125;</span><br><span class="line">		arr[index + <span class="number">1</span>] = next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a><strong>希尔排序</strong></h3><p>如果存在一个数组为{2，3，4，5，6，1}那么使用直接插入排序会导致算法效率很慢</p>
<p>所以说是对插入排序的一种优化，它是分组对每组进行排序，又叫做缩小增量排序</p>
<p><img src="/2022/09/01/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/6613c382-2362-11eb-a750-d6c52a23d5aa.gif" alt="![]{}"></p>
<p><strong>为什么希尔排序效率更高</strong></p>
<p>由于开始时，步长的取值较大，每个子序列中的元素较少，排序速度较快，到排序后期步长取值逐渐变小，子序列中元素个数逐渐增多，但由于前面工作的基础，大多数元素已经基本有序，所以排序速度仍然很快。就是判断的多了，移动的次数变少，所以速度变快。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(<span class="type">int</span> arr[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> gap = arr.<span class="built_in">size</span>() / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">			<span class="type">int</span> index = i;</span><br><span class="line">			<span class="type">int</span> now = arr[index];</span><br><span class="line">			<span class="keyword">if</span>(now &lt; arr[index - gap]) &#123;</span><br><span class="line">				<span class="keyword">while</span>(index - gap &gt;= <span class="number">0</span> &amp;&amp; now &gt; arr[index - gap]) &#123;</span><br><span class="line">					arr[index] = arr[index - gap];</span><br><span class="line">					index -= gap;</span><br><span class="line">				&#125;</span><br><span class="line">				a[index] = now;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><strong>选择排序</strong></h3><h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a><strong>简单选择排序</strong></h4><p>思想：将数组中的数据遍历，先拿第一个进行比较，看后面的有没有比这更小的，有的话交换，没有就第二个进行比，依次比较，一共需要比数组大小-1次 。第<strong>i</strong>次排序后序列的前<strong>i</strong>项都会变得有序。</p>
<p><img src="/2022/09/01/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.gif"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单选择排序 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(<span class="type">int</span> arr[])</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">			<span class="keyword">if</span>(a[i] &gt; a[j])</span><br><span class="line">				<span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">			</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二元选择排序————简单选择排序的改进"><a href="#二元选择排序————简单选择排序的改进" class="headerlink" title="二元选择排序————简单选择排序的改进"></a><strong>二元选择排序————简单选择排序的改进</strong></h4><p>简单选择排序，每趟循环只能确定一个元素排序后的定位。我们可以考虑改进为每趟循环确定两个元素（当前趟最大和最小记录）的位置,从而减少排序所需的循环次数。改进后对n个数据进行排序，最多只需进行[n&#x2F;2]趟循环即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(<span class="type">int</span> arr[])</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len / <span class="number">2</span>; i++) &#123;</span><br><span class="line">		<span class="type">int</span> maxIndex = i;</span><br><span class="line">		<span class="type">int</span> minIndex = i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; len - i; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j] &gt; arr[maxIndex]) maxIndex = j;</span><br><span class="line">			<span class="keyword">if</span>(a[j] &lt; arr[minIndex]) minIndex = j;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="built_in">swap</span>(a[i], arr[minIndex]);</span><br><span class="line">		<span class="built_in">swap</span>(a[j], arr[maxIndex]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a><strong>堆排序</strong></h3><p>大根堆，从小到大排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> i, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = arr[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">2</span> * i + <span class="number">1</span>; k &lt; length; k = k * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(k + <span class="number">1</span> &lt; length &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>]) k++;</span><br><span class="line">		<span class="keyword">if</span>(arr[k] &lt;= temp) <span class="keyword">break</span>;</span><br><span class="line">		arr[i] = arr[k];</span><br><span class="line">		i = k;</span><br><span class="line">	&#125;</span><br><span class="line">	arr[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="built_in">adjustHeap</span>(arr, i, size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = size - <span class="number">1</span>; j &gt; <span class="number">0</span>; j --) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[j]);</span><br><span class="line">		<span class="built_in">adjustHeap</span>(arr, <span class="number">0</span>, j);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><strong>冒泡排序</strong></h3><p>思想：从前向后遍历, 每次判断相邻两数是否前数小于后数, 不满足则交换两数, 直到不需要交换为止 </p>
<p><img src="/2022/09/01/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/v2-33a947c71ad62b254cab62e5364d2813_b.gif"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; size - <span class="number">1</span> - i; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">                arr[j] ^= arr[j + <span class="number">1</span>] ^= arr[j] ^= arr[j + <span class="number">1</span>]; </span><br><span class="line">                <span class="comment">// 和swap(arr[j], arr[j + 1])一样, </span></span><br><span class="line">                <span class="comment">// 扩展下类似写法 </span></span><br><span class="line">                <span class="comment">// a = (a + b) - (b = a)</span></span><br><span class="line">                <span class="comment">// a ^= b ^= a ^= b </span></span><br><span class="line">                <span class="comment">// python中 a,b = b,a </span></span><br><span class="line">                <span class="comment">// c++11新标准:std::tie(a, b) = std::make_tuple(b, a);</span></span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!count) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><strong>快速排序</strong></h3><p>先找一个<strong>基准值</strong>，一般为数组大小&#x2F;2，左边找到一个比基准值大的数，右边找到一个比基准值小的数，然后进行交换，算完之后左边的都为比基准值小的，右边都为比基准值大的，但不能保证他们是有序的，所以还需要对左右生成的数据进行二次排序，通过不断递归使得整个数组有序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// srand((unsigned)time(NULL));</span></span><br><span class="line">	<span class="type">int</span> i = l, j = r, key = (<span class="built_in">rand</span>() % (r - l)) + l;</span><br><span class="line">	<span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">		<span class="keyword">while</span>(i &lt; j &amp;&amp; arr[key] &lt;= arr[j]) j--;</span><br><span class="line">		<span class="keyword">while</span>(i &lt; j &amp;&amp; arr[key] &gt;= arr[i]) i++;</span><br><span class="line">		<span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">		<span class="built_in">QuickSort</span>(arr, l, i - <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">QuickSort</span>(arr, i + <span class="number">1</span>, r)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速选择-第K大数"><a href="#快速选择-第K大数" class="headerlink" title="快速选择:第K大数"></a><strong>快速选择:第K大数</strong></h3><p>基于快速排序思想，通过基准数的位置找出第K大数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QuickSelect</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> key = l;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[i] &gt; arr[key])&#123;</span><br><span class="line">			<span class="built_in">swap</span>(arr[i], arr[key]);</span><br><span class="line">			key ++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(key == k) <span class="keyword">return</span> key;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(key &lt; k) <span class="keyword">return</span> <span class="built_in">QuickSelect</span>(arr, k, key + <span class="number">1</span>, r);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">QuickSelect</span>(arr, k, l, key - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><strong>归并排序</strong></h3><p>利用完全二叉树特性，把数组递归拆成左右两个大小几乎相等部分，直到左右两部分不能再次拆分，深度相同的相邻左右子部分合并，直到整个数组有序，一共需要进行logn次合并和拆分。</p>
<p><img src="/2022/09/01/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> temp[], <span class="type">int</span> l, <span class="type">int</span> mid, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i = l, j = mid + <span class="number">1</span>, k = l;</span><br><span class="line">	<span class="keyword">while</span>(i != mid + <span class="number">1</span> &amp;&amp; j != r + <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[i] &lt;= arr[j]) temp[k ++] = arr[i ++];</span><br><span class="line">		<span class="keyword">else</span> temp[k ++] = arr[j ++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i != mid + <span class="number">1</span>) temp[k ++] = arr[i ++];</span><br><span class="line">	<span class="keyword">while</span>(j != r   + <span class="number">1</span>) temp[k ++] = arr[j ++];</span><br><span class="line">	<span class="keyword">for</span>(i = l; i &lt;= r; i++) arr[i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> temp[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">MergeSort</span>(arr, temp, l, mid);</span><br><span class="line">	<span class="built_in">MergeSort</span>(arr, temp, mid + <span class="number">1</span>, r);</span><br><span class="line">	<span class="built_in">Merge</span>(arr, temp, l, mid, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="桶排序-x2F-基数排序"><a href="#桶排序-x2F-基数排序" class="headerlink" title="桶排序&#x2F;基数排序"></a><strong>桶排序&#x2F;基数排序</strong></h3><p>把数据分组，放在一个个的桶中，然后对每个桶里面分别进行排序。</p>
<p><img src="/2022/09/01/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif"></p>
<p><img src="/2022/09/01/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F2.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSort</span><span class="params">(<span class="type">int</span> arr[])</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> maxNum = arr[<span class="number">0</span>];</span><br><span class="line">	<span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[i] &gt; maxNum) &#123;</span><br><span class="line">			max = arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> size = std::<span class="built_in">to_string</span>(maxNum).<span class="built_in">length</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>, n = <span class="number">1</span>; k &lt; size; k++, n* = <span class="number">10</span>) &#123;</span><br><span class="line">		<span class="type">int</span> bucket[len][<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">			<span class="type">int</span> temp = arr[i];</span><br><span class="line">			<span class="type">int</span> gewei = temp / n % <span class="number">10</span>;</span><br><span class="line">			bucket[i][gewei] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j ++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(bucket[j][i] != <span class="number">0</span>)</span><br><span class="line">					arr[t++] = bucket[j][i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>秋招复习</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 新的开始</title>
    <url>/2020/01/16/2020-%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<p>也不知道2019年里我改变了多少，依然那么单纯，幻想，焦虑，抑郁，仍然不知道自己现在能不能接受自己，一无是处，一事无成，那有如何呢，都过去了呢，也回不去了呢。</p>
<p>想过2019年曾自己立了无数个flag，现在又实现了几个，对未来还是好迷茫，感受不到光。</p>
<p>人生下来有什么意义呢，活着，死去。时间冲刷后又留下了什么，死后又去了哪里？</p>
<span id="more"></span>

<p>最近一直在做噩梦，梦见自己死去，也不知道自己到底梦见了多少回，等我慢慢地由恐惧变成了适应，我也逐渐开始麻木，这样的梦也消失了</p>
<p>我常常幻想着自己的未来，我的未来是怎样的呢，看着网上的大亨衣食无忧游戏人间，我却只能看到自己未来忙于生计养活自己，我还是没有遇见我心仪的人，一个人潦草度日</p>
<p>我一直不是一个贫困的人，我愧为人</p>
<p>不想平庸，却无能为力</p>
<p>发了那么多牢骚还是带面对现实，唉，晚安世界，或许</p>
<p>永别世界</p>
<p>今天早上又起的很晚，制定好的英语计划没有开始就已经结束，拖延症晚期，唉</p>
<p>去医院做了做检查，中度抑郁，开了半年来士普和百适可，希望能恢复吧</p>
<p>心态崩了</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>洛谷[P3373]线段树模板2</title>
    <url>/2019/11/16/%E6%B4%9B%E8%B0%B7-P3373-%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%9D%BF2/</url>
    <content><![CDATA[<h1 id="【模板】线段树-2"><a href="#【模板】线段树-2" class="headerlink" title="【模板】线段树 2"></a>【模板】线段树 2</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如题，已知一个数列，你需要进行下面三种操作：</p>
<ul>
<li><p>将某区间每一个数乘上 $x$</p>
</li>
<li><p>将某区间每一个数加上 $x$</p>
</li>
<li><p>求出某区间每一个数的和</p>
</li>
</ul>
<span id="more"></span>

<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含三个整数 $n,m,p$，分别表示该数列数字的个数、操作的总个数和模数。</p>
<p>第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。</p>
<p>接下来 $m$ 行每行包含若干个整数，表示一个操作，具体如下：</p>
<p>操作 $1$： 格式：<code>1 x y k</code>  含义：将区间 $[x,y]$ 内每个数乘上 $k$</p>
<p>操作 $2$： 格式：<code>2 x y k</code>  含义：将区间 $[x,y]$ 内每个数加上 $k$</p>
<p>操作 $3$： 格式：<code>3 x y</code>  含义：输出区间 $[x,y]$ 内每个数的和对 $p$ 取模所得的结果</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出包含若干行整数，即为所有操作 $3$ 的结果。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 5 38</span><br><span class="line">1 5 4 2 3</span><br><span class="line">2 1 4 1</span><br><span class="line">3 2 5</span><br><span class="line">1 2 4 2</span><br><span class="line">2 3 5 5</span><br><span class="line">3 1 4</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">17</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>【数据范围】</p>
<p>对于 $30%$ 的数据：$n \le 8$，$m \le 10$<br>对于 $70%$ 的数据：$n \le 10^3 $，$ m \le 10^4$<br>对于 $100%$ 的数据：$ n \le 10^5$，$ m \le 10^5$</p>
<p>除样例外，$p &#x3D; 571373$</p>
<p>（数据已经过加强^_^）</p>
<p>样例说明：</p>
<p> <img src="https://cdn.luogu.com.cn/upload/pic/2255.png"> </p>
<p>故输出应为 $17$、$2$（ $40 \bmod 38 &#x3D; 2$ ）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lr rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rr rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">500007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> _lgl&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> N, M, P, a, b, c;</span><br><span class="line">    LL sum[maxn &lt;&lt; <span class="number">2</span>], add[maxn &lt;&lt; <span class="number">2</span>], mul[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        sum[rt] = sum[lr] + sum[rr];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mul[rt] != <span class="number">1</span>)&#123;</span><br><span class="line">            LL s = mul[rt];</span><br><span class="line"><span class="comment">//            add[rt] = (add[rt] * s) % P;</span></span><br><span class="line">            mul[lr] = (mul[lr] * s) % P;</span><br><span class="line">            mul[rr] = (mul[rr] * s) % P;</span><br><span class="line">            add[lr] = (add[lr] * s) % P;</span><br><span class="line">            add[rr] = (add[rr] * s) % P;</span><br><span class="line">            sum[lr] = (sum[lr] * s) % P;</span><br><span class="line">            sum[rr] = (sum[rr] * s) % P;</span><br><span class="line">            mul[rt] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(add[rt])&#123;</span><br><span class="line">            LL s = add[rt];</span><br><span class="line">            add[lr] = (add[lr] + s) % P;</span><br><span class="line">            add[rr] = (add[rr] + s) % P;</span><br><span class="line">            sum[lr] = (sum[lr] + (add[rt] * (m - (m &gt;&gt; <span class="number">1</span>)))) % P; </span><br><span class="line">            sum[rr] = (sum[rr] + (add[rt] * (m &gt;&gt; <span class="number">1</span>))) % P;</span><br><span class="line">            add[rt] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*inline void down(int rt, int m)&#123;</span></span><br><span class="line"><span class="comment">        if(mul[rt] != 1)&#123;</span></span><br><span class="line"><span class="comment">            add[rt] = add[rt] * mul[rt] % P;</span></span><br><span class="line"><span class="comment">            sum[lr] = sum[lr] * mul[rt] % P;</span></span><br><span class="line"><span class="comment">            sum[rr] *= mul[rt]%P;</span></span><br><span class="line"><span class="comment">            add[lr] *= mul[rt]%P;</span></span><br><span class="line"><span class="comment">            add[rr] *= mul[rt]%P; </span></span><br><span class="line"><span class="comment">            mul[lr] *= mul[rt]%P;</span></span><br><span class="line"><span class="comment">            mul[rr] *= mul[rt]%P;</span></span><br><span class="line"><span class="comment">            mul[rt] = 1;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        if(add[rt])&#123;</span></span><br><span class="line"><span class="comment">            add[lr] += add[rt]%P;</span></span><br><span class="line"><span class="comment">            add[rr] += add[rt]%P;</span></span><br><span class="line"><span class="comment">            sum[lr] += add[rt] * (m - (m &gt;&gt; 1)) % P;</span></span><br><span class="line"><span class="comment">            sum[rr] += add[rt] * (m &gt;&gt; 1) % P;</span></span><br><span class="line"><span class="comment">            add[rt] = 0;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        mul[rt] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;sum[rt]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(lson);</span><br><span class="line">        <span class="built_in">build</span>(rson);</span><br><span class="line">        <span class="built_in">up</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update_1</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> c, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">            add[rt] = (add[rt] + c) % P;</span><br><span class="line">            sum[rt] = (sum[rt] + (LL) c * (r - l + <span class="number">1</span>))%P;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">down</span>(rt, r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= m) <span class="built_in">update_1</span>(L, R, c, lson);</span><br><span class="line">        <span class="keyword">if</span>(m &lt;  R) <span class="built_in">update_1</span>(L, R, c, rson);</span><br><span class="line">        <span class="built_in">up</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update_2</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> c, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line">            mul[rt] = (mul[rt] * c) % P;</span><br><span class="line">            add[rt] = (add[rt] * c) % P;</span><br><span class="line">            sum[rt] = (sum[rt] * c) % P;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">down</span>(rt, r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= m) <span class="built_in">update_2</span>(L, R, c, lson);</span><br><span class="line">        <span class="keyword">if</span>(m  &lt; R) <span class="built_in">update_2</span>(L, R, c, rson);</span><br><span class="line">        <span class="built_in">up</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> sum[rt];</span><br><span class="line">        <span class="built_in">down</span>(rt, r - l + <span class="number">1</span>);</span><br><span class="line">        LL ret = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= m) ret = ret + (<span class="built_in">query</span>(L, R, lson))%P;</span><br><span class="line">        <span class="keyword">if</span>(m &lt;  R) ret = ret + (<span class="built_in">query</span>(L, R, rson))%P;</span><br><span class="line">        <span class="keyword">return</span> ret%P;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;testdata.in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;N,&amp;M,&amp;P);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, N, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(M--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">            <span class="keyword">if</span>(a == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">                <span class="built_in">update_1</span>(a, b, c, <span class="number">1</span>, N, <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">                <span class="built_in">update_2</span>(a, b, c, <span class="number">1</span>, N, <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(a, b, <span class="number">1</span>, N, <span class="number">1</span>)%P);</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    _lgl::<span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Segment Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷[P3372]线段树模板1</title>
    <url>/2019/11/16/%E6%B4%9B%E8%B0%B7-P3372-%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%9D%BF1/</url>
    <content><![CDATA[<h1 id="【模板】线段树-1"><a href="#【模板】线段树-1" class="headerlink" title="【模板】线段树 1"></a>【模板】线段树 1</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如题，已知一个数列，你需要进行下面两种操作：</p>
<ol>
<li>将某区间每一个数加上 $k$。</li>
<li>求出某区间每一个数的和。</li>
</ol>
<span id="more"></span>

<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个整数 $n, m$，分别表示该数列数字的个数和操作的总个数。</p>
<p>第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。</p>
<p>接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下：</p>
<ol>
<li><code>1 x y k</code>：将区间 $[x, y]$ 内每个数加上 $k$。</li>
<li><code>2 x y</code>：输出区间 $[x, y]$ 内每个数的和。</li>
</ol>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出包含若干行整数，即为所有操作 2 的结果。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">1 5 4 2 3</span><br><span class="line">2 2 4</span><br><span class="line">1 2 3 2</span><br><span class="line">2 3 4</span><br><span class="line">1 1 5 1</span><br><span class="line">2 1 4</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11</span><br><span class="line">8</span><br><span class="line">20</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>对于 $30%$ 的数据：$n \le 8$，$m \le 10$。<br>对于 $70%$ 的数据：$n \le {10}^3$，$m \le {10}^4$。<br>对于 $100%$ 的数据：$1 \le n, m \le {10}^5$。</p>
<p>保证任意时刻数列中所有元素的绝对值之和 $\le {10}^{18}$。</p>
<p><strong>【样例解释】</strong></p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/2251.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lr rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rr rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, M, n, m;</span><br><span class="line">LL add[maxn &lt;&lt; <span class="number">2</span>], sum[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> _lgl&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        sum[rt] = sum[lr] + sum[rr];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(add[rt]) &#123;</span><br><span class="line">            add[lr] += add[rt];</span><br><span class="line">            add[rr] += add[rt];</span><br><span class="line">            sum[lr] += add[rt] * (m - (m &gt;&gt; <span class="number">1</span>));</span><br><span class="line">            sum[rr] += add[rt] * (m &gt;&gt; <span class="number">1</span>); </span><br><span class="line">            add[rt] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;sum[rt]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(lson);</span><br><span class="line">        <span class="built_in">build</span>(rson);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> c, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">            add[rt] += c;</span><br><span class="line">            sum[rt] += (LL) c * (r - l + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(rt, r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= m) <span class="built_in">update</span>(L, R, c, lson);</span><br><span class="line">        <span class="keyword">if</span>(m &lt; R) <span class="built_in">update</span>(L, R, c, rson);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> sum[rt];</span><br><span class="line">        <span class="built_in">pushdown</span>(rt, r - l + <span class="number">1</span>);</span><br><span class="line">        LL ret = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= m) ret += <span class="built_in">query</span>(L, R, lson);</span><br><span class="line">        <span class="keyword">if</span>(m &lt;  R) ret += <span class="built_in">query</span>(L, R, rson);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;N,&amp;M);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, N, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(M --)&#123;</span><br><span class="line">            <span class="type">int</span> a, b, c, skt;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;skt);</span><br><span class="line">            <span class="keyword">if</span>(skt == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(a, b, <span class="number">1</span>, N, <span class="number">1</span>));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">                <span class="built_in">update</span>(a, b, c, <span class="number">1</span>, N, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    _lgl::<span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Segment Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>EK - Edmond-Karp</title>
    <url>/2019/11/13/EK-Edmond-Karp/</url>
    <content><![CDATA[<h1 id="EK-Edmond-Karp"><a href="#EK-Edmond-Karp" class="headerlink" title="EK - Edmond-Karp"></a>EK - Edmond-Karp</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EK(Edmond-Karp) : 利用bfs实现，时间复杂度O（V*E^2）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rg register</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">2147483647</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> _lgl&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m, s, t, tot, head[maxn]; </span><br><span class="line">    <span class="type">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">        <span class="type">int</span> to, val, next;</span><br><span class="line">    &#125;e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Pre</span>&#123;</span><br><span class="line">        <span class="type">int</span> point, edge;</span><br><span class="line">    &#125;pre[maxn];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span>&#123;</span><br><span class="line">        e[++tot].to = y;</span><br><span class="line">        e[tot].next = head[x];</span><br><span class="line">        e[tot].val  = z;</span><br><span class="line">        head[x] = tot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> f = <span class="number">1</span>, s = <span class="number">0</span>; <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(c);c = <span class="built_in">getchar</span>()) <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; <span class="built_in">isdigit</span>(c);c = <span class="built_in">getchar</span>()) s = (s &lt;&lt; <span class="number">3</span>) + (s &lt;&lt; <span class="number">1</span>) + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> f * s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">        queue &lt;<span class="type">int</span>&gt; q; </span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">memset</span>(pre,<span class="number">-1</span>, <span class="built_in">sizeof</span>(pre));</span><br><span class="line">        vis[s] = <span class="literal">true</span>; q.<span class="built_in">push</span>(s);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> now = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = head[now]; i; i = e[i].next)&#123;</span><br><span class="line">                <span class="type">int</span> to = e[i].to;</span><br><span class="line">                <span class="keyword">if</span>(!vis[to] &amp;&amp; e[i].val)&#123;</span><br><span class="line">                    pre[to].point = now;</span><br><span class="line">                    pre[to].edge  = i;</span><br><span class="line">                    <span class="keyword">if</span>(to == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    vis[to] = <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">EK</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">            <span class="type">int</span> mi = inf;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = t; i != s; i = pre[i].point) mi = mi &lt; e[pre[i].edge].val ? mi : e[pre[i].edge].val;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = t; i != s; i = pre[i].point)&#123;</span><br><span class="line">                e[pre[i].edge].val -= mi;</span><br><span class="line">                e[pre[i].edge^<span class="number">1</span>].val += mi;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += mi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>(), s = <span class="built_in">rd</span>(), t = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x, y, z, i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">            x = <span class="built_in">rd</span>(), y = <span class="built_in">rd</span>(), z = <span class="built_in">rd</span>(), <span class="built_in">add</span>(x,y,z), <span class="built_in">add</span>(y,x,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">EK</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    _lgl::<span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
</search>
